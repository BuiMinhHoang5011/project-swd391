/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactDOMServer = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  var ReactVersion = '18.2.0';

  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  // by calls to these methods by a Babel plugin.
  //
  // In PROD (or in packages without access to React internals),
  // they are left as they are instead.

  function warn(format) {
    {
      {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        printWarning('warn', format, args);
      }
    }
  }
  function error(format) {
    {
      {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        printWarning('error', format, args);
      }
    }
  }

  function printWarning(level, format, args) {
    // When changing this logic, you might want to also
    // update consoleWithStackDev.www.js as well.
    {
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var stack = ReactDebugCurrentFrame.getStackAddendum();

      if (stack !== '') {
        format += '%s';
        args = args.concat([stack]);
      } // eslint-disable-next-line react-internal/safe-string-coercion


      var argsWithFormat = args.map(function (item) {
        return String(item);
      }); // Careful: RN currently depends on this prefix

      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610
      // eslint-disable-next-line react-internal/no-production-logging

      Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
  }

  function scheduleWork(callback) {
    callback();
  }
  var VIEW_SIZE = 512;
  var currentView = null;
  var writtenBytes = 0;
  function beginWriting(destination) {
    currentView = new Uint8Array(VIEW_SIZE);
    writtenBytes = 0;
  }
  function writeChunk(destination, chunk) {
    if (chunk.length === 0) {
      return;
    }

    if (chunk.length > VIEW_SIZE) {
      // this chunk may overflow a single view which implies it was not
      // one that is cached by the streaming renderer. We will enqueu
      // it directly and expect it is not re-used
      if (writtenBytes > 0) {
        destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
      }

      destination.enqueue(chunk);
      return;
    }

    var bytesToWrite = chunk;
    var allowableBytes = currentView.length - writtenBytes;

    if (allowableBytes < bytesToWrite.length) {
      // this chunk would overflow the current view. We enqueue a full view
      // and start a new view with the remaining chunk
      if (allowableBytes === 0) {
        // the current view is already full, send it
        destination.enqueue(currentView);
      } else {
        // fill up the current view and apply the remaining chunk bytes
        // to a new view.
        currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view

        destination.enqueue(currentView);
        bytesToWrite = bytesToWrite.subarray(allowableBytes);
      }

      currentView = new Uint8Array(VIEW_SIZE);
      writtenBytes = 0;
    }

    currentView.set(bytesToWrite, writtenBytes);
    writtenBytes += bytesToWrite.length;
  }
  function writeChunkAndReturn(destination, chunk) {
    writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more

    return true;
  }
  function completeWriting(destination) {
    if (curr